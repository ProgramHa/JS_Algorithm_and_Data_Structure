$ 목표

- 알고리즘의 정의

- 알고리즘 해결 계획

- 계획의 비교와 대조 및 빈도 카운터, 투 포인터, 분할 정복 등을 수립


# 알고리즘이란?

 - 특정 작업을 달성하기 위한 과정이나 일련의 단계


# 알고리즘을 알아야하는 이유

 - 프로그래밍에서 수행하는 아주 기본적 작업에서 복잡한 어플리케이션을 구축할 때에도 일종의 알고리즘이 포함됨

 - 따라서 문제을 해결할 방법을 마련할 수 있도록 결정해야함


# 알고리즘을 더 잘 이해하는 법

 1. 문제 해결을 위한 계획 수립

 2. 일반적인 문제 해결 패턴을 파악


# 문제 해결을 위한 단계
 
 1단계: 문제 이해하기

 2단계: 구체적 예제 알아보기

 3단계: 문제 세분화 하기

 4단계: 문제 해결 또는 단순화

 5단계: 문제 되돌아보기 및 리팩토링


# 1단계: 문제의 이해

 - 참고할 만한 좋은 책 '어떻게 문제를 풀 것인가 - George Polya'

 1. 문제를 나의 방식대로 다시 생각할 수 있는가?

 2. 문제가 어떤 입력값을 담고 있는지 이해하고 있는가?

 3. 문제의 해결책에서 나와야 할 결과값은 무엇일까?

 4. 입력값이 출력값을 결정할 수 있을까? = 문제를 풀기위한 충분한 정보가 주어졌는지 확인
   
   ㄴ 주어진 정보만 이용해서 문제를 풀 수 있는가?
 
 5. 문제의 일부인 데이터의 중요한 부분에 어떻게 라벨을 지정할 수 있을까? = 문제에서 무엇이 가장 중요한가
   
   ㄴ 라벨을 뭘 쓸지, 어떤 용어를 사용할 지


(예제)
두 숫자를 가지고 합계를 반환하는 함수 작성

// 1. 문제를 나의 방식대로 다시 생각할 수 있는가?
"implemet addition"
// 2. 문제가 어떤 입력값을 담고 있는지 이해하고 있는가?
    // ints?
    // float?
    // 엄청 큰 숫자를 위한 string은 어떨까?
// 3. 문제의 해결책에서 나와야 할 결과값은 무엇일까?
    // ints? float? string?
// 4. 입력값이 출력값을 결정할 수 있을까? = 문제를 풀기위한 충분한 정보가 주어졌는지 확인

// 5. 문제의 일부인 데이터의 중요한 부분에 어떻게 라벨을 지정할 수 있을까? = 문제에서 무엇이 가장 중요한가


# 2단계: 구체적 예제들

 - 예시를 떠올리는 것이 문제를 이해하는 데 도움을 준다

 - 예시는 온전성 검사를 제공하므로 최종 해결책을 입력했다면 잘 작동하는지 검사 수행이 가능

@ 구체적 예시를 떠올리는 법

 - 간단한 예시로 시작하기 (ex) 입력값과 출력값의 순서대로 예시를 두세 개 작성해보기

 - 간단한 예시에서 복잡한 예시로 진행

 - 빈 입력값이 있는 예시 확인

 - 유효하지 않은 입력값 예시 확인

(예제)
문자열을 취하고 각 문자의 수를 반환하는 함수를 작성하시오

charCount("aaaa"); // {a:4}
charCount("hello); // {h:1, e:1, l:2, o:1}


"my phone number is 182763" // 공백도 고려? 기호, 밑줄? 숫자는 포함?
"Hello hi" // 대소문자를 무시? H, h를 둘다 포함하려면?

charCount("") // 값이 없으면 무엇을 반환해야하나?? null값이나 객체값을 반환하면?


# 3단계: 문제 세분화

 - 진행해야 할 단계를 명확하게 작성해보기 (너무 세부적인 것이 아닌 해결책의 기본적 구성요소를 작성)
   
   ㄴ 감이 안잡히거나 이해되지 않는 부분을 파악하여 이해할 수 있게 도와줌


(예제)
문자열을 취하고 각 문자의 수를 반환하는 함수를 작성하시오
(조건: 영숫자와 소문자에 주의할 것이라고 가정)

charCount("aaaa"); 
/* {
    a: 4
} */
charCount("hello);
/* {
    h: 1,
    e: 1,
    l: 2,
    o: 1
} */
charCount("Your PIN number is 1234!")
/* {
    1: 1,
    2: 1,
    3: 1,
    4: 1,
    b: 1,
    e: 1,
    i: 2,
    m: 1,
    n: 2,
    o: 1,
    p: 1,
    r: 2,
    s: 1,
    u: 1,
    y: 1
} */

function charCount(str){
  // do something
  // 문자열 내의 소문자와 영숫자의 문자인 키를 지닌 객체를 반환
}

function charCount(str){
  // 마지막에 반환할 객체 만들기
  // 문자열에 각 문자열에 대한 루프 적용하기
    // 만약 char가 숫자/문자이며 객체에 있다면, 하나를 갯수에 더함
    // char가 숫자/문자이며 객체에 없다면, 추가하고 값을 1로 설정
    // 만약 문자가 다른 것(공백, 온점, 기타...)이면 아무것도 하지 않음
  // 객체 반환하기
}


# 4단계: 문제 해결 또는 단순화

 - 문제를 해결할 수 있다면 해결하고, 없다면 더 단순한 문제를 해결하기
  
  ㄴ 다른 모든 것에 집중하기 위해 시간이 많이 소요되는 부분은 무시

$ 단순화

 - 수행하는 작업에서 가장 어려운 작업을 찾으면 잠깐 어려운 부분 무시

 - 단순한 해결책 작성 이후 어려운 부분이 가능하면 다시 통합


(예제)
문자열을 취하고 각 문자의 수를 반환하는 함수를 작성하시오
(조건: 영숫자와 소문자에 주의할 것이라고 가정)

charCount("aaaa"); 
/* {
    a: 4
} */
charCount("hello);
/* {
    h: 1,
    e: 1,
    l: 2,
    o: 1
} */
charCount("Your PIN number is 1234!")
/* {
    1: 1,
    2: 1,
    3: 1,
    4: 1,
    b: 1,
    e: 1,
    i: 2,
    m: 1,
    n: 2,
    o: 1,
    p: 1,
    r: 2,
    s: 1,
    u: 1,
    y: 1
} */

function charCount(str){
  // do something
  // 문자열 내의 소문자와 영숫자의 문자인 키를 지닌 객체를 반환
}

function charCount(str){
  // 마지막에 반환할 객체 만들기
  // 문자열에 각 문자열에 대한 루프 적용하기
    // 만약 char가 숫자/문자이며 객체에 있다면, 하나를 갯수에 더함
    // char가 숫자/문자이며 객체에 없다면, 추가하고 값을 1로 설정
    // 만약 문자가 다른 것(공백, 온점, 기타...)이면 아무것도 하지 않음
  // 객체 반환하기
}
 // 루프에 문제가 있다면 해당 함수, 객체로 만든다면 첫 문자로 작업하거나 첫 다섯문자를 하드코딩 해본다( 좋은 방법은 아님 )
 // 첫 문자를 처리해보면서 패턴이 보임

function charCount(str){
 // 마지막에 반환할 객체 만들기
 var result = {};
 // 문자열에 각 문자열에 대한 루프 적용하기
 for(var i = 0; i < str.length; i++) {
   var char = str[i].toLowerCase()
   // 만약 char가 숫자/문자이며 객체에 있다면, 하나를 갯수에 더함
   if(result[char] > 0){
      result[char]++;
   }
   // char가 숫자/문자이며 객체에 없다면, 추가하고 값을 1로 설정
   else {
     result[char] = 1;
   };
 }
   // 만약 문자가 다른 것(공백, 온점, 기타...)이면 아무것도 하지 않음
 // 객체 반환하기
 return result;
}


# 5단계: 문제 되돌아보기 및 리팩토링

 - 문제의 해결책을 작성했다면 다시 되돌아 보면서 리팩토링 해보는 것이 좋음

 - 각 구성요소를 한 줄씩 살펴 보면서 마음에 들지 않는 부분, 코드의 형태, 해석 방법, 이해하기 쉬운지에 대해 중점

 - 효율성 높은 코드가 좋지만, 대체로 효율성과 가독성 사이의 균형을 맞춰야함

% 리팩토링 점검 질문

 - 결과를 확인할 수 있는가?

 - 결과를 다른 방식으로 도출할 수 있는가? <= 다른 접근방식으로도 생각 할수 있는가?

 - 한 눈에 보고 이해할 수 있는가? <= 코드가 얼마나 직관적인가?

 - 결과나 방법을 다른 문제에도 적용할 수 있을까? <= 해결책이 다른 문제와 유사점이 있는가?

 - 해결책의 성능을 향상 시킬수 있는가?

 - 회사에 근무 중 이라면 코드를 향상 시킬수 있는 다른 방법이 생각 나는가? <= 회사 가이드라인? 언어의 규칙? 간격은 일정한가?

 - 다른 사람들은 어떤 방식으로 문제를 해결하는가?


@ 이제까지의 예제문제를 리팩토링 해보기

function charCount(str) {
  var obj = {};
  for (var i = 0; i < str.length; i++) {
    var char = str[i].toLowerCase();
    if (/[a-z0-9]/.test(char)) {
      if (obj[char] > 0) {
        obj[char]++;
      } else {
        obj[char] = 1;
      };
    }
  }
  return obj;
}

function charCount(str) {
    var obj = {};
    for (var char of str) {     // for of를 사용해서 i와 char 두 변수를 선언하지 않고, char하나만 선언
      if (isAlphaNumeric(char)) {   // 정규표현식을 사용하면 느리기 때문에 코드 인덱스값으로 특문과 공백 거르기
        char = char.toLowerCase();    // i를 사용하지 않아서 char를 그대로 사용, if문 안에 넣어서 독립
        obj[char] = ++obj[char] || 1;   // 참 같은 값(truthy)이 있으면 추가하고, 거짓같은 값(falsy)이라면 1로 설정하는 코드
      }
    }
    return obj;
}

function isAlphaNumeric(char) {
    var code = char.charCodeAt(0);
    if (!(code > 47 && code < 58) &&    // numeric (0-9)
        !(code > 64 && code < 91) &&    // upper alpha (A-Z)
        !(code > 96 && code < 123))        {// lower alpha (a-z))
        return false;
    }
    return true;
}


charCodeAt(0) // 문자의 인덱스 번호를 알 수 있는 코드

/*
/^[a-zA-Z0-9]+$/

=

!(code > 47 && code < 58) &&    // numeric (0-9)
!(code > 64 %% code < 91) &&    // upper alpha (A-Z)
!(code > 96 && code 123)        // lower alpha (a-z)
*/