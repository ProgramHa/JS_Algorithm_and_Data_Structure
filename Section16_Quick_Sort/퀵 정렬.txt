# 퀵 정렬

 - 합병 정렬과 마찬가지로 재귀적 방식으로 배열의 요소가 0개 또는 1개의 요소만 남을 때 까지 분할하여 정렬

 - pivot이라고 부르는 단일 요소를 선택하여 그 보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동

 - 위 과정을 반복하며 정렬


[ 5, 2, 1, 8, 4, 7, 6, 3 ] => 5를 초기 pivot이라고 가정

              5
        3           7
  1        4     6     8
     2


# pivot 헬퍼 함수

 - 배열이 주어지면 요소를 pivot 포인트로 지정하여 배열 속 요소를 재배치 하는 함수 작성

 - pivot보다 작은 값은 모두 왼쪽으로 이동하며 pivot보다 큰 값은 모두 오른쪽으로 이동

 - 이때 양쪽의 순서는 중요하지 않음

 - 헬퍼는 반드시 제자리에서 작업을 수행하고, 절대 새 배열을 만들면 안되며 pivot인덱스를 반환해야 함


# pivot 선택시 알아야 할 사항

 - 퀵 정렬의 실행시간은 pivot선택 위치에 따라 달라질 수 있음

 - 이상적으로는 데이터 집합의 중간값이 되도록 선택해야 함

 - pivot값은 랜덤 값, 첫 번째 또는 마지막 번째도 상관없음

 - 편의상 작성할 코드에는 항상 첫 번째 값을 pivot으로 지정 ( Big O에도 영향을 미침 )

# pivot 헬퍼 예제

let arr = [ 5, 2, 1, 8, 4, 7, 6, 3 ]

pivot(arr); // 4;

arr;
// 다음 배열들 중 하나라도 가능함:
// [ 2, 1, 4, 3, 5, 8, 7, 6 ]
// [ 1, 4, 3, 2, 5, 7, 6, 8 ]
// [ 3, 2, 1, 4, 5, 7, 6, 8 ]
// [ 4, 1, 2, 3, 5, 6, 8, 7 ]
// 이 외에도 가능한 배열들도 있음!


# pivot 헬퍼 함수 의사코드

 - 배열, 시작 인덱스, 끝 인덱스의 3개의 인수를 받는 pivot 또는 파티션이라는 함수 작성 ( 시작 인덱스:0, 끝 인덱스: 배열 길이 -1 )

 - 배열의 시작 부분에서 pivot을 선택하고 현재 pivot 인덱스를 변수로 저장 ( 마지막에 pivot을 바꿀 위치를 계속 확인 )

 - 시작부터 끝까지 배열을 루프함

 - 만약 살펴보는 요소보다 pivot이 클 경우 pivot 인덱스 변수를 증가시킨 다음 현재 요소와 pivot 인덱스의 요소를 교환

 - 맨 마지막에 시작했던 pivot과 pivot 인덱스를 바꾼 다음 pivot 인덱스를 반환


# 퀵 정렬 의사코드

 - 전체 배열의 가장 앞에서 pivot 헬퍼 함수 호출

 - 업데이트된 pivot 인덱스를 헬퍼가 반환하면 pivot 헬퍼를 재귀적으로 왼쪽과 오른쪽에 호출

 - 하위 배열에 2개 미만의 요소가 있을 때 수행


# 퀵 정렬의 Big O

시간복잡도(최고)    시간복잡도(평균)    시간복잡도(최악)    공간복잡도
  O(n log n)        O(n log n)         O(n^2)            O(log n)


O(n log n) :  배열 항목 n개 일때 log n번 분해하고 pivot과 n번 비교해야 하기때문

최악이 O(n^2)인 이유 : 이미 정렬된 배열을 정렬한다고 할 때, n번 분해하고 pivot과 n번 비교해야 하기때문

= 이미 정렬된 배열을 다룰 경우 pivot을 첫 번째 항목 대신 무작위로 고르면 해결 가능