# 비교 알고리즘들의 평균 시간복잡도

 - 버블 정렬 - O(n^2)

 - 삽입 정렬 - O(n^2)

 - 선택 정렬 - O(n^2)

 - 퀵 정렬 - O(n log n)

 - 합병 정렬 - O(n log n)

 - 여기서 더 빨라질 수 있을까?

   ㄴ 가능하지만 비교를 통한 정렬법이 아닌 다른 방법을 사용

   = 비교 정렬의 하한 점근선 최대가 n log n이기 때문


# 기수 정렬

 - 기수 정렬은 특이한 정렬 알고리즘으로 숫자로 작동함 (이진수로 작동, 정렬할 데이터는 숫자여야함)

 - 요소 간 크고 작음을 묻지 않음

 - 숫자 크기에 대한 정보를 자릿수로 인코딩 한다는 사실을 이용 (ex) 네 자리 수는 두 자리 수 보다 더 큼


# 기수 정렬 작동 방식

[1556, 4, 3556, 593, 408, 4386, 902, 7, 8157, 86, 9637, 29]

 - 0~9 까지의 버킷을 만듦

 - 각 숫자의 끝 자리 숫자를 기준으로 버킷에 담아서 그룹으로 묶음 (이때, 정렬된 상태는 아님)

 - 버킷에 숫자 기준으로 다시 정렬 

[902, 593, 4, 1556, 3556, 4386, 86, 7, 8157, 9637, 408, 29]

 - 끝 자리 숫자의 왼쪽 자리 수를 확인하고 자리 수를 올려가면서 반복

[902, 4, 7, 408, 29, 9637, 1556, 3556, 8157, 4386, 86, 593]

[4, 7, 29, 86, 8157, 4386, 408, 1556, 3556, 593, 9637, 902]

[4, 7, 29, 86, 408, 593, 902, 1556, 3556, 4386, 8157, 9637]


# 기수 정렬 헬퍼 함수

 1. getDigit(num, place) - 수와 위치를 가져온 다음 그 위치의 숫자를 반환 
    
    = 문자열로 변환하여 음수 인덱스를 사용 또는 10의 거듭제곱으로 계산

    getDigit(12345, 0) // 5
    getDigit(12345, 1) // 4
    getDigit(12345, 2) // 3
    getDigit(12345, 3) // 2
    getDigit(12345, 4) // 1
    getDigit(12345, 5) // 0

 2. digitCount(num) - 입력된 숫자에 대한 자릿수를 계산해서 반환

    digitCount(1) // 1
    digitCount(25) // 2
    digitCount(314) // 3

 3. mostDigits(nums) - 수 목록을 가져와 가장 자릿수가 많은 수가 무엇인지 자릿수 계산을 통해 알려줌

    mostDigits([1234, 56, 7]) // 4
    mostDigits([1, 1, 11111, 1]) // 5 
    mostDigits([12, 34, 56, 78]) // 2


# 기수 정렬 의사코드

 - 숫자 목록을 받는 radixSort 함수를 정의

 - 가장 큰 수가 몇 자리인지 찾기 (mostDigits)

 - 0 부터 가장 큰 자릿수 까지 루프 (k=0)

 - 루프 진행할 때 마다 각 자릿수를 넣을 버킷 배열을 생성 (0~9)

 - 다음 루프를 수행할 때 마다 각각의 수를 올바른 버킷에 대입 (k번째 자릿수)

 - 기존 배열을 버킷의 값으로 교체

 - 배열 반환


 # 기수 정렬의 Big O

시간복잡도(최고)    시간복잡도(평균)    시간복잡도(최악)    공간복잡도
    O(nk)              O(nk)             O(nk)           O(n + k)

n: 정렬할 항목 수나 정수의 수 = 배열의 길이, 정렬하려는 수의 갯수

k: 이러한 수의 길이 = 이러한 수의 자릿수