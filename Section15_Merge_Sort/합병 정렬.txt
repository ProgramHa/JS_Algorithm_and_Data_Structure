# 중급 정렬 알고리즘(Intermediate Sorting Algorithms)

# 학습 목표

 1. 기본 정렬 알고리즘의 한계 이해

 2. 합병 정렬(merge sort) 구현

 3. 퀵 정렬(quick sort) 구현

 4. 지수 정렬(radix sort) 구현


# 중급 정렬 알고리즘을 배우는 이유

 - 기본 정렬 알고리즘은 큰 규모에 맞지 않음

 - (예) 1만개 요소를 버블 정렬로 작업하면 꽤 많은 시간이 걸림

 - (예) 1만개 요소를 합병 정렬로 작업하면 짧은 시간만으로 충분


# 빠른 정렬 알고리즘은

 - 빠른 정렬 알고리즘 들은 시간 복잡도 O(n^2)에서 O(n log n)으로 향상

 - 효율성과 단순성은 상충한다

 - 이 효율적인 알고리즘은 더 어렵고, 더 길고, 길지않아도 더 이상함


# 합병 정렬

 - 합병과 정렬이라는 두 가지 조합

 - 0개의 요소, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용

 - 배열을 더 작은 배열로 나누는 방식 ( 0이나 1요소 배열이 될 때 까지 진행 )

(예시)
[ 8, 3, 5, 4, 7, 6, 1, 2 ] =>

[ 8, 3, 5, 4 ], [ 7, 6, 1, 2 ] =>

[ 8, 3 ], [ 5, 4 ], [ 7, 6 ], [ 1, 2 ] =>

[ 8 ], [ 3 ], [ 5 ], [ 4 ], [ 7 ], [ 6 ], [ 1 ], [ 2 ] =>

[ 3, 8 ], [ 4, 5 ], [ 6, 7 ], [ 1, 2 ] =>

[ 3, 4, 5, 8 ], [ 1, 2, 6, 7 ] =>

[ 1, 2, 3, 4, 5, 6, 7, 8 ]


# 배열 합병을 위한 사전 지식

 - 정렬된 두 배열을 합병할 함수를 먼저 구현

 - 정렬된 두 배열이 주어지면 헬퍼 함수는 입력 배열 두 개에 있는 모든 요소를 포함하는 정렬된 새 배열을 만듬

 - 이 함수는 O(n+m)의 시간 복잡도와 O(n+m)의 공간 복잡도로 실행 ( n: 첫 번째 배열 크기, m: 두 번째 배열의 크기 )

# 배열 합병의 의사코드

 - 입력 두 개를 취하는 함수를 정의하여 마지막에 반환할 빈 배열을 만듦

 - 각 입력 배열에서 가장 작은 값부터 시작 (카운터 함수 2개 i=0, j=0, while 사용 추천)

 - i, j가 각각의 배열의 끝에 도달하지 않았다면 첫 번째 배열의 값으로 첫 번째 항목을 취한 다음 두 번째 배열의 첫 번째 항목 값과 비교

 - 만약 첫 번째 배열 항목이 더 작다면 결과 배열에 집어넣은 첫 번째 배열의 항목이 다음 항목으로 넘어감

 - 만약 첫 번째 배열에 있는 항목이 더 크다면 두 번째 배열의 값을 취하여 결과로 넣은 다음 두 번째 배열의 다음 값으로 넘어감

 - 배열 하나를 완료한 다음에 다른 배열의 남은 값을 모두 넣음


# 합병 정렬의 의사코드

 - 배열이 비거나 1개의 요소만 남을 때 까지 재귀하며 배열을 반으로 나눔 ( arr.slice를 사용해 배열 나누기 )

 - 준비된 배열을 다시 원래 길이가 될 때까지 배열 합병 함수를 이용해 정렬하며 합병

 - 합병된 배열을 반환


# 합병 정렬의 일어나는 논리 구조

                            [10,24,73,76]
                        mergeSort([10,24,76,73])

            [10,24]            merge             [76,73]
        mergeSort([10,24])                  mergeSort([76,73])

    [10]     merge    [24]               [76]     merge    [73]
mergeSort([10]) mergeSort([24])     mergeSort([76]) mergeSort([73])


# 합병 정렬의 Big O

시간복잡도(최고)    시간복잡도(평균)    시간복잡도(최악)    공간복잡도
  O(n log n)        O(n log n)         O(n log n)          O(n)


O(n log n)인 이유 - 배열 항목 n개 일때 log n번 나눈 결과를 합병하기 위해 n번 확인해야 하기때문

공간복잡도가 O(n)인 이유 - 배열항목 n개 만큼의 공간을 할당해야 하기 때문