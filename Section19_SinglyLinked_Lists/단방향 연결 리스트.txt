# 학습 목표

 1. 단방향 연결 리스트가 무엇인가

 2. 내장 배열 구조와 비교

 3. 단방향 연결 리스트 클래스 정의 및 데이터의 삽입, 추출등


# 연결 리스트

 - 값과 위치 포인터 값을 저장하는 노드들 끼리 연결되어 구성된 데이터 구조

 - head: 연결 리스트의 시작 노드, tail: 연결 리스트의 마지막 노드 | 중간에 있는 노드를 추적 하지않음


# 배열과 연결리스트의 차이

 $ 리스트: 인덱스가 없음, 다음 노드까지 next 포인터로 연결됨, 임의 접근이 불가능하고 순차 접근만 가능 

 $ 배열: 인덱스로 순서를 매김, 새로운 항목을 추가하기 힘듬, 임의 접근이 가능


# 의사코드

push 의사코드

 - 주어진 값을 받아 새로운 노드 생성
 
 - 만약 head가 없다면 head와 tail을 새로운 노드를 가리키도록 함

 - 리스트가 비어있지 않다면 마지막 노드의 next를 새로 생성된 노드를 가리키도록 하고 길이에 +1

 - 연결 리스트를 반환

pop 의사코드

 - 만약 노드가 리스트에 없으면 undefined를 반환 (리스트 확인: head가 null, 리스트 길이가 0)

 - 비어있지 않다면 tail에 이를 때까지 전체 리스트를 반복하며 따라감

 - 마지막에서 두 번째 노드의 next를 null로 설정하고 tail값을 마지막에서 두 번째 노드로 변경

 - 리스트의 길이를 -1

 - 금방 제거한 노드를 반환

shift 의사코드

 - 만약 노드가 없다면 undefined를 반환

 - 비어있지 않다면 head 속성을 변수에 저장

 - 현재 head의 next 노드를 가리키도록 head 속성을 업데이트

 - 리스트의 길이를 -1

 - 제거된 이전 head 노드의 값 반환

unshift 의사코드

 - 시작 위치에 추가하려는 새로운 노드를 생성

 - 만약 head가 없을 경우 head와 tail 모두를 새로운 노드를 가리키도록 설정

 - 이미 있다면 새로운 노드의 next를 현재의 head 값으로 설정 

 - head를 새로운 노드로 설정하고

 - 리스트의 길이를 +1

 - 연결 리스트를 반환

get 의사코드

 - 인덱스를 인수로 받음

 - 만약 인덱스가 음수이거나, 리스트의 길이와 같거나 클 경우 null을 반환

 - 지정한 위치에 이를때까지 반복하며 이동후 노드를 반환 (counter, while, .next를 사용)

set 의사코드

 - 변경할 인덱스와 값을 인수로 받음

 - get함수를 이용함

 - 만약 노드를 찾지 못하면 false를 반환

 - 노드를 찾았다면 노드 값을 인수로 받은 값으로 업데이트하고 true를 반환

insert 의사코드

 - 변경할 인덱스와 값을 인수로 받음

 - 만약 인덱스가 0보다 작거나 리스트의 길이보다 클 경우 flase를 반환

 - 만약 인덱스가 리스트의 길이와 같다면 push함수를 이용해 끝 노드에 삽입

 - 만약 인덱스가 0이면 unshift함수를 이용해 시작노드에 삽입

 - 위의 경우가 아니라면 get함수를 이용해 인덱스를 찾음 (index - 1로 호출)

 - 이전 노드의 next를 새로운 노드를 가리키도록 지정

 - 새 노드의 next를 이전 노드의 next를 가리키도록 지정

 - 리스트의 길이를 +1

 - true를 반환

remove 의사코드

 - 변경할 인덱스를 인수로 받음

 - 만약 인덱스가 0보다 작거나 리스트의 길이보다 크거나 같을 경우 undefined를 반환

 - 만약 인덱스가 리스트의 길이 - 1과 같다면 pop함수를 이용해 끝 노드를 삭제

 - 만약 인덱스가 0이면 shift함수를 이용해 시작노드를 삭제

- 위의 경우가 아니라면 get함수를 이용해 인덱스를 찾음 (index - 1로 호출)

- 이전 노드의 next를 .next.next로 지정

- 리스트의 길이 -1

- 삭제한 노드의 값을 반환

reverse 의사코드

 - head와 tail을 교환

 - next라는 변수 생성

 - prev라는 변수 생성

 - node 또는 current라는 값을 head값으로 초기화 

 - 리스트를 반복하며 진행

 - next의 .next의 값을 현재 노드의 .next 값으로 변경

 - 다음 노드의 next 값을 prev 노드의 값으로 변경

 - prev의 값을 node의 값으로 변경

 - node의 값을 next값으로 변경


# 단방향 연결 리스트의 Big O

 - 삽입: O(1)

 - 삭제: 노드 위치에 따라 다름 = O(1) or O(n)

 - 탐색: O(N)

 - 접근: O(N)


% 정리
 
 - 삽입과 삭제를 자주하고, 주어진 순서대로 데이터를 관리할 때는 단방향 연결 리스트는 배열의 대안이 될 수 있음

 - 배열과 달리 내장된 인덱스를 가지고 있지 않음

 - 자료구조에서 스택이나 큐 등의 특수 목적 자료구조에서 단방향 연결 리스트를 활용함