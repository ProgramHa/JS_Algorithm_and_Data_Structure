# 학습 목표
 
 1. 버블 정렬 구현

 2. 선택 정렬 구현

 3. 삽입 정렬 구현

 4. 기본 3가지 정렬 알고리즘이 중요한 이유

# 정렬은 무엇인가

 - 정렬 알고리즘: Collection의 항목을 재배열하는 과정

 - 숫자를 작은 숫자에서 큰 숫자로 가거나 반대인 오름차순, 내림차순으로 정렬

 - 이름을 알파뱃 순서로 정렬

 - 영화 객체를 개봉년도, 수익 등으로 정렬

# 정렬을 왜 배워야 하는가

 - 정렬이 프로그래밍에서 매우 흔하게 사용되기 때문

 - 데이터를 정렬하는 방법이 많아서 각 알고리즘에 장단점이 있음

 & 참고하면 좋은 사이트 - 정렬 알고리즘 애니메이션


# 자바스크립트 내장 정렬 메소드

 - JS에는 내장된 정렬 메소드가 있지만 항상 올바르게 작동하는 것은 아님

["Steele", "Colt", "Data Structures", "Algorithms"].sort()
//["Algorithms", "Colt", "Data Structures", "Steele"] - 정렬됨

[6, 4, 15, 10].sort()
//[10, 15, 4, 6] - 이상하게 정렬됨

 - 이유: 유니코드 코드 포인트가 기본 정렬 순서이기 때문에 문자열이 아니면 원하는 값을 얻기 힘듬

 - 내장 정렬 메소드는 선택적 비교 함수를 인자로 전달 받음

 - 이 함수를 통해 원하는 정렬 방식을 알릴 수 있음

 - 이 함수는 A와 B의 2개의 항목을 구조로 작성

 - 만약 A와 B의 2개의 항목이 있는 상태에서 JS는 두 항목을 비교할 때 마다 함수 호출

 - 만약 음수를 반환하면 A가 B보다 앞에 온다고 결정

 - 만약 양수를 반환하면 A가 B보다 뒤에 온다고 결정

 - 만약 0을 반환하면 A와 B를 동일하게 취급하고 한꺼번에 정렬


(예제)

function numberSort(num1, num2) {
    return num1 - num2;
}

[6, 4, 15, 10].sort(numberSort)
//[4, 6, 10, 15] 

function compareByLen(str1, str2) {
    return str1.length - str2.length;
}

"Steele", "Colt", "Data Structures", "Algorithms"].sort(compareByLen)
//["Colt", "Steele", "Algorithms", "Data Structures"]


# 버블 정렬

 - 숫자를 오름차순 정렬한다고 가정할 때 가장 큰 숫자가 한 번에 하나씩 뒤로 이동

 - 루프를 돌면서 각 항목을 비교하면서 비교 대상보다 크면 교환하고, 아니면 비교대상과 그 뒤의 항목을 비교


$ 구현 전 알아야할 교환방법

 - 몇가지 교환법 있음 그 중 대표적인 2가지

// ES5
function swap(arr, idx1, idx2) {
    var temp = arr[idx1];
    arr[idx1] = arr[idx2];
    arr[idx2] = temp;
}

// ES2015
const swap = (arr, idx1, idx2) => {
    [arr[idx1],arr[idx2]] = [arr[idx2],arr[idx1]]
}

# 버블 정렬 의사코드

 - bubbleSort 함수를 정의하고 숫자 배열을 인자로 받고 루프를 시작함

 - i라는 변수를 가지고 배열의 맨 끝에서 루프를 시작해서 맨 앞에서 끝남

 - 외부 루프 안에 j라는 변수가 포함된 내부 루프가 있고, 내부 루프는 처음부터 i - 1까지 실행

 - 만약 arr[j]가 arr[j+1]보다 크면 두 값을 교환

 - 정렬된 배열을 반환


% 만약 배열이 어느정도 정렬된 배열이라면

 - 정렬이 이미 끝났어도 루프가 끝날 때 까지 계속 반복함 = 자원 낭비


# 버블 정렬의 시간 복잡도

기본적으로 O(n^2)

그러나 데이터가 거의 정렬됐거나 이미 정렬이 끝난 상태에서 noSwaps 변수가 있으면 선형 시간에 가까움 = O(n) = Best Case