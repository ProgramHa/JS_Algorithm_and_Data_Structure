# 학습목표
 
 1. 탐색 알고리즘이 무엇인지 설명

 2. 배열에 선형 탐색(Linear Search)을 실시

 3. 정렬된 배열에 이진 탐색(Binary Search)을 실시

 4. 나이브 문자열 탐색 알고리즘
 
 5. KMP 문자열 탐색 알고리즘 구현


# 선행 탐색(Linear Search)

 - 가장 간단한 탐색 방법은 모든 개별 항목을 순서대로 살펴보면서 원하는 값인지 확인

 - 정렬되지 않은 값을 탐색할 때 좋음
 
 - JS 내장 선형 탐색 메소드: indexOf, includes, find, findIndex

 - 시간 복잡도 = O(n)

% 선형 탐색 의사코드

 - 함수는 여러 개의 숫자가 들어있는 배열을 인수로 사용

 - 전체 배열에 대한 루프를 만들고 입력한 값과 동일한지 확인

 - 만약 동일하면 값의 인덱스를 반환, 없다면 -1을 반환


# 선형 탐색 Big O

 - 데이터 크기에 따라 다르지만 최고의 경우는 O(1) 하지만 드물다

 - 최악의 경우는 O(n)

 - 평균적으로는 O(n)


# 이진 탐색(Binary Search)

 - 매우 빠른 탐색 속도를 가지고 있음

 - 한번에 한 항목씩 제외하는 것이 아닌 절반을 제외할 수 있음

 - 이진 탐색은 반드시 데이터가 정렬되어 있어야 함

 - 데이터에 중간점을 잡으면서 탐색

 - 기본적으로 분할과 정복(Divide and Conquer)을 사용


% 이진 탐색 의사코드

 - 함수는 정렬되어 있는 배열과 탐색 값을 인수로 받음 ( 숫자만 받는다고 가정 )

 - 좌측을 나타내는 인덱스 포인터 변수와 우측을 나타내는 포인터 변수를 선언 ( 우측 값은 배열의 길이에서 -1한 값)

 - 좌측이 우측에 가까워지면서 반복 연산

 - 반복 중 항목을 찾았는지 확인하고 아니면 계속 반복함

 - 중간점을 나타내는 포인터 변수를 선언
   
   ㄴ 만약 탐색 값과 중간점 값이 일치하면 인덱스를 반환

   ㄴ 만약 값이 너무 작으면 좌측 포인터를 중간점 인덱스로 변경

   ㄴ 만약 값이 너무 크면 우측 포인터의 값을 중간점 인덱스로 변경
 
 - 만약 모든 연산이 종료 후 값이 없다면 -1을 반환 

# 이진 탐색의 Big O

 - 최고의 경우 O(1)

 - 최악과 평균의 경우 O(log n)

 
 # 나이브 문자열 탐색

 - 긴 문자열에서 짧은 문자열이 등장하는 횟수를 센다고 가정

 - 가장 간단한 방법 중 하나: 문자쌍을 하나씩 확인

% 나이브 문자열 탐색 의사코드

 - 문자열 2개을 인수로 받는 함수 stringSearch를 정의

 - 긴 문자열의 각 문자를 반복하고 짧은 문자열을 반복하는 중첩 반복문 작성

 - 만약 루프 중 문자가 일치하지 않으면 내부 루프에서 벗어남

 - 만약 루프 중 문자가 일치하면 계속해서 문자열을 확인

 - 만약 내부루프가 완료되어 일치 문자열을 찾았다면 count를 증가하고 마지막에 count를 반환 ( count가 존재하지 않으면 0 )