# 학습목표

 1. 양방향 연결 리스트 작성

 2. 단방향 연결 리스트와 비교

 3. 단방향 연결 리스트의 기본 연산과 비교


# 양방향 연결 리스트의 작동 방식

 - 기본적으로 단방향 연결 리스트와 비슷하지만 next말고도 prev요소가 있음

 - prev요소가 있기 때문에 맨 끝 요소를 찾거나 역순으로 순회할 때 유용하다

 - 다양한 유용성 === 더 많은 메모리


# 의사코드

push 메소드

 - 값을 가지는 새로운 노드를 생성하고 head가 null인지, 리스트 길이가 0인지 확인
 
 - 만약 head가 null이면(또는 리스트 길이가 0이면) head와 tail을 새로 만든 노드로 지정

 - 만약 아니라면 현재 tail을 찾아 tail노드의 next값을 새로운 노드로 설정

 - 새로만든 노드의 prev값을 이전 tail 노드로 설정

 - tail의 값을 새로만든 노드로 지정

 - 연결 리스트 길이 +1

 - 리스트 반환

pop 의사코드

 - 만약 head가 null이면(또는 리스트 길이가 0이면) undefined를 반환

 - 만약 아니라면 현재 tail을 출력할 수 있도록 변수에 저장

 - 만약 리스트의 길이가 1이라면 head와 tail을 null로 설정

 - 이전 노드가 tail이 되도록 설정

 - 새로 지정된 tail의 next를 null로 설정

 - 연결 리스트의 길이 -1

 - pop한 값 반환

shift 의사코드

 - 만약 head가 null이면(또는 리스트 길이가 0이면) undefined를 반환

 - 아니라면 head값을 변수에 저장 (oldHead)

 - 만약 리스트의 길이가 1이라면 head와 tail을 null로 설정

 - head값을 이전 head값으로 설정

 - head값의 prev값을 null로 설정

 - oldHead의 next값을 null로 설정

- 연결 리스트의 길이 -1

 - shift한 값 반환

unshift 의사코드

 - 값을 가지는 새로운 노드 생성

 - 만약 리스트의 길이가 0이면 head와 tail을 새로 생성된 노드로 설정

 - 아니라면 현재 headd의 prev값을 새로운 노드가 되도록 설정

 - 새로운 노드의 next값을 현재 head로 설정

 - head를 새로운 노드로 설정

 - 리스트의 길이 +1

 - 리스트를 반환

get 의사코드

 - index를 인수로 받는 함수 작성

 - 만약 index가 음수이거나 리스트 길이와 같거나 크다면 null을 반환

 - 아니라면 index가 리스트의 길이의 절반보다 작은지 클지 확인

 - 만약 작다면 head부터 시작하여 반복하며 값을 찾아 노드를 반환

 - 만약 크다면 tail부터 시작하여 반복하며 값을 찾아 노드를 반환

set 의사코드

 - 변경할 값과 index를 받는 함수 작성

 - get메소드를 사용하여 값을 검색

 - 만약 get이 노드를 반환하면 해당 노드의 값을 변경하고 true를 반환

 - 아니라면 false를 반환

insert 의사코드

 - 만약 index가 음수이거나 리스트의 길이보다 크면 false를 반환

 - 만약 index가 0이면 unshift함수를 호출

 - 만약 index가 리스트의 길이가 같으면 push함수를 호출

 - 이외의 경우 get함수를 index - 1을 인수로 호출

 - 찾은 노드와 이전 노드와 다음 노드의 next값과 prev값을 올바르게 지정

 - 리스트의 길이 +1

 - true를 반환

remove 의사코드

 - 만약 index가 음수이거나 리스트의 길이보다 크거나 같으면 undefined를 반환

 - 만약 index가 0이면 shift함수를 호출

 - 만약 index가 리스트의 길이 - 1과 같으면 pop함수를 호출

 - 이외의 경우 get함수를 이용하여 삭제할 노드 탐색

 - 탐색된 노드의 이전 노드와 다음 노드의 next 값과 prev값을 바꿔서 리스트에서 제거

 - 탐색된 노드의 next값과 prev값을 null로 설정

 - 리스트의 길이를 -1

 - 삭제된 값 반환


# 양방향 연결 리스트의 Big O

 - 삽입: O(1)

 - 삭제: O(1)

 - 탐색: O(N)

 - 접근: O(N)

 & 인덱스르 양방향으로 나누어 head에 가까운지 tail에 가까운지에 따라 최적화 되어 기술적으로는 O(N/2)이지만 O(N)임


% 정리

 - 양방향 연결 리스트는 이전 노드를 가리키는 포인터가 있다는 점 말고는 단방향 연결 리스트와 같음

 - 단방향 연결 리스트와 달리 노드를 탐색하는 데 절반의 시간 밖에 소요됨

 - 그러나 추가로 만든 포인터는 메모리를 더 소모함